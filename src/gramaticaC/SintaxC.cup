package gramaticaC;
import java_cup.runtime.*;
import Operaciones.*;
import Tablas.*;  
import verificaciones.*;
import objetos.*;
import ObjetosC.*;
import java.util.*;


parser code {:

    public int jerarquia = 0;
    public String tipoActual = "";
    public OperacionesC op = new OperacionesC();
    public VerifC verif = new VerifC();
    public TablaSimbolos tabla;
    public static Integer itMetodo = null;
    public String auxTipo = "";
    /*variables exclusiva para la comprobacion de parametros, Produccion -> METODO*/
    public boolean metodoCorrecto = false;
    public Clase claseUsar = null;
    public String len = "";
    public int it = 0;
    public String idClase = "";

    public boolean auxFor = false;

    public SintaxC(AnalizadorLexico4 lexer, TablaSimbolos tabla){
        super(lexer);
        this.tabla = tabla;
    }

    public void setAccion(String tipo, String mensaje, String accion){
        System.out.println(tipo+"   "+mensaje);
    }

    public void syntax_error(Symbol s){
        setAccion("ERROR", "Error sintaxis linea: "+s.left+" columna: "+s.right,"");
    }

:}

    terminal coma, punto, puntoComa, dosPuntos, llave_a, llave_b, parentesis_a, parentesis_b, agrupacion_a, agrupacion_b,
             condBreak, condInclude, visual, python, java, principal, comilla, comillaSimple, mas, menos, por, div,
             modulo, tipoVoid, tipoChar, tipoInteger, tipoFloat, tipoConst, main, mayor, menor, igual, admiracion,
             ampersand, pleca, condIf, condElse, condSwitch, condCase, condDef, condFor, condWhile, condDo, printf, 
             scanf, scanfInt, scanfFloat, scanfChar, clscr, getch, numero, id, resto, numeral, verdadero, falso,
             comentario_a, enter, comentario_b, comentario_c, and, or;

    non terminal INICIO, LIBRERIAS, VARIABLES, CONSTANTES, ASIGNACIONES, VARS, BREAK,
                 MAIN, CUERPO_MAIN, VARIABLES_MAIN, CLASES, VECTOR_GETCH,
                 CLASES2, IF, OP, ELSE, FOR, WHILE, DO_WHILE, SWITCH, CASES,   
                 LECTURA_DATOS, TIPO, MENSAJE, RESTO_MENSAJE, CLSCR, GETCH, VAR_TEXTO,
                 AND, OR, VAR_CASE, VARS2, COMENTARIO_A, ENTER, ENTER2, COMENTARIO_B, TEXTO_COM;

    non terminal String TEXTO, TEXTO2, JAVA_CLASES, TIPO_VAR, MODULOS, TIPO_VAR_FOR;
    
    non terminal Boolean OPERACION, VAR, METODOS, VECTOR, VECTOR_OP, VALOR, VAR_LECTURA, METODOS_MAIN;

    non terminal Integer DIM, DIM2;

    non terminal Boolean PARAMETROS, PARAMETROS2;

    non terminal Boolean  EXT, VAR_FOR;

    non terminal String OP_COND, VAL_COND;

    non terminal String METODO_COND, VECTOR_COND, BOOLEAN;

    non terminal ArrayList<String> PARAM, PARAM2, CONSTRUCTOR;

    precedence left mas, menos;
    precedence left por, div, modulo;

    precedence left or;
    precedence left and;    

    start with INICIO;

    INICIO ::= LIBRERIAS VARIABLES MAIN
;
    LIBRERIAS ::= LIBRERIAS numeral condInclude comilla visual:a comilla {: parser.op.activarLenguaje(a.toString(), parser.tabla, ""); :} ENTER2 
    |             LIBRERIAS numeral condInclude comilla python:a comilla {: parser.op.activarLenguaje(a.toString(), parser.tabla, ""); :} ENTER2 
    |             LIBRERIAS numeral condInclude comilla java:a punto JAVA_CLASES:b comilla {: parser.op.activarLenguaje(a.toString(), parser.tabla, ""); :} ENTER2 
    |             LIBRERIAS numeral condInclude menor id mayor ENTER2
    |             LIBRERIAS numeral condInclude menor id punto id mayor ENTER2
    |            
;
    JAVA_CLASES ::= por:a {: RESULT=a.toString(); :}
    |               id:a {: RESULT=a.toString(); :}
;
    VARIABLES ::= VARIABLES CONSTANTES {: /*LISTO*/ :}
    |             VARIABLES ASIGNACIONES
    |             VARIABLES VARS {: /*LISTO*/ :}
    |             VARIABLES CLASES
    |               
;
    CONSTANTES ::= tipoConst TIPO_VAR:a {: parser.tipoActual = a; :} id:b igual OPERACION:c puntoComa {: parser.op.agregarNuevaVar(parser.tabla.getObC(), b.toString(), a, "Constante", parser.jerarquia, true, "", null); :} ENTER2
;
    VALOR ::= igual OPERACION:a {: RESULT=a; :}
    |        {: RESULT=null; :}
;
    ASIGNACIONES ::= id:a igual {: parser.tipoActual = parser.verif.devolverTipoVar(parser.tabla.getObC(), parser.jerarquia, a.toString()); :} OPERACION:b puntoComa {: if(b){  parser.tabla.getObC().getListVariables().get(VerifObjetos.iterador).getListAsignaciones().add(parser.jerarquia); parser.tabla.getObC().getListVariables().get(VerifObjetos.iterador).setValor(true);      } :} ENTER2
    |                VECTOR:a igual OPERACION:b puntoComa {: if(a && b){ /*VER LO DE LAS ASIGNACIONES*/ } else { System.out.println("no es posible asignar en el arreglo"); } :} ENTER2
;
    VARS ::= TIPO_VAR:a id:b  {: parser.tipoActual=a; :} VALOR:c {: if(c!=null){ if(c){parser.op.agregarNuevaVar(parser.tabla.getObC(), b.toString(), a, "Variable", parser.jerarquia, c, "", null); } else { System.out.println("soy falso"); } } else { parser.op.agregarNuevaVar(parser.tabla.getObC(), b.toString(), a, "Variable", parser.jerarquia, false, "", null); } :} VARS2 puntoComa ENTER2
    |        TIPO_VAR:a id:b DIM:c {: parser.tipoActual=a; if(a!=null){ parser.op.agregarNuevaVar(parser.tabla.getObC(), b.toString(), a, "Arreglo", parser.jerarquia, true, "", c); } :} VARS2 puntoComa ENTER2
;
    VARS2 ::= coma id:a VALOR:b {: if(b != null){ if(b){ parser.op.agregarNuevaVar(parser.tabla.getObC(), a.toString(), parser.tipoActual, "Variable", parser.jerarquia, b, "", null); } } else { parser.op.agregarNuevaVar(parser.tabla.getObC(), a.toString(), parser.tipoActual, "Variable", parser.jerarquia, false, "", null); } :} VARS2
    |         coma id:a DIM:b {: if(b != null){ parser.op.agregarNuevaVar(parser.tabla.getObC(), a.toString(), parser.tipoActual, "Arreglo", parser.jerarquia, true, "", b); } :}
    |
;
    TIPO_VAR ::= tipoInteger {: RESULT="Integer"; :}
    |            tipoChar {: RESULT="Char"; :}
    |            tipoFloat {: RESULT="Float"; :}
;
    OPERACION ::= parentesis_a OPERACION:a parentesis_b {: RESULT=a; :}
    |             OPERACION:a mas OPERACION:b {: if(a && b){ RESULT=true; } else { RESULT=false; } :}
    |             OPERACION:a menos OPERACION:b {: if(a && b){ RESULT=true; } else { RESULT=false; } :}
    |             OPERACION:a por OPERACION:b {: if(a && b){ RESULT=true; } else { RESULT=false; } :}
    |             OPERACION:a div OPERACION:b {: if(a && b){ RESULT=true; } else { RESULT=false; } :}
    |             OPERACION:a modulo OPERACION:b {: if(a && b){ RESULT=true; } else { RESULT=false; } :}
    |             VAR:a {: RESULT=a; :}
;
    VAR ::= comillaSimple id comillaSimple {: /*Verificar si en verdad es un char */ RESULT=true;   :}
    |       numero:a {: RESULT=parser.verif.verificarNumero(parser.tabla.getObC(), "Integer", parser.tipoActual, a.toString()); :}
    |       numero:a punto:b numero:c {: RESULT=parser.verif.verificarNumero(parser.tabla.getObC(), "Float", parser.tipoActual, a.toString()+b.toString()+c.toString()); :} 
    |       VECTOR_OP:a {: RESULT=a; :}
    |       METODOS:a {: RESULT=a; :}
    |       id:a {: RESULT = parser.verif.verificarIdOperacion(parser.tabla.getObC(), a.toString(), parser.jerarquia, parser.tipoActual); :}
    |       menos numero:a {: RESULT=parser.verif.verificarNumero(parser.tabla.getObC(), "Integer", parser.tipoActual, a.toString()); :}
    |       menos numero:a punto:b numero:c {: RESULT=parser.verif.verificarNumero(parser.tabla.getObC(), "Float", parser.tipoActual, a.toString()+b.toString()+c.toString()); :}
    |       menos VECTOR_OP:a {: RESULT=a; :}
    |       menos METODOS:a {: RESULT=a; :}
    |       menos id:a {: RESULT = parser.verif.verificarIdOperacion(parser.tabla.getObC(), a.toString(), parser.jerarquia, parser.tipoActual); :}
;
    VECTOR ::= id:a {:  parser.tipoActual="Integer";  :} DIM:b {:  if(parser.verif.verifExistenciaArreglo(parser.tabla.getObC(), parser.jerarquia, a.toString())){ parser.tipoActual = parser.tabla.getObC().getListArreglos().get(VerifObjetos.iterador).getTipo(); RESULT=true; } else {  RESULT=false; }  :}
;
    VECTOR_OP ::= id:a {: parser.auxTipo = parser.tipoActual; parser.tipoActual = "Integer"; :} DIM:b {: parser.tipoActual = parser.auxTipo; parser.auxTipo = ""; if(b != null){ RESULT=parser.verif.verifVectorOperacion(parser.tabla.getObC(), a.toString(), b, parser.jerarquia, parser.tipoActual); }  :}
;
    DIM ::= DIM2:a agrupacion_a OPERACION:b agrupacion_b {: if(b!= null){ if(b){Integer suma = a + 1; RESULT=suma;} else { RESULT=null; } } else { RESULT=null; } :}
;
    DIM2 ::= DIM2:a agrupacion_a  OPERACION:b agrupacion_b {: if(b != null){ if(b){ Integer suma = a + 1; RESULT=suma; } else { RESULT=null; } } else { RESULT=null; } :}
    | {: RESULT = 0; :}
;
    MAIN ::= tipoVoid main parentesis_a parentesis_b ENTER2 {: parser.jerarquia++; :} llave_a ENTER2 CUERPO_MAIN llave_b {: parser.jerarquia--; :} ENTER2
;
    CUERPO_MAIN ::= CUERPO_MAIN VARIABLES_MAIN
    |               CUERPO_MAIN IF
    |               CUERPO_MAIN FOR
    |               CUERPO_MAIN WHILE
    |               CUERPO_MAIN DO_WHILE
    |               CUERPO_MAIN SWITCH
    |               CUERPO_MAIN LECTURA_DATOS
    |               CUERPO_MAIN MENSAJE
    |               CUERPO_MAIN CLSCR
    |               CUERPO_MAIN GETCH
    |               CUERPO_MAIN COMENTARIO_A
    |               CUERPO_MAIN COMENTARIO_B
    |
;
    VARIABLES_MAIN ::= ASIGNACIONES
    |                 VARS
    |                 METODOS_MAIN 
    |                 CLASES   
;
    METODOS ::= python:a punto id:b parentesis_a  {: parser.len=a.toString(); parser.metodoCorrecto=parser.verif.verificarMetodoOp(parser.tabla, parser.tipoActual, a.toString(), "", parser.jerarquia, b.toString());  :}  PARAMETROS:c parentesis_b {: if(parser.metodoCorrecto){ if(c){ RESULT=true; } else { RESULT=false;  } } else { RESULT=false; }  :}
    |           visual:a punto id:b parentesis_a {: parser.len=a.toString(); parser.metodoCorrecto=parser.verif.verificarMetodoOp(parser.tabla, parser.tipoActual, a.toString(), "", parser.jerarquia, b.toString()); :} PARAMETROS:c parentesis_b {: if(parser.metodoCorrecto){ if(c){ RESULT=true;  } else { RESULT=false; } } else { RESULT=false; } :}
    |           java:a punto id:b punto id:c parentesis_a {: parser.len=a.toString(); parser.metodoCorrecto=parser.verif.verificarMetodoOp(parser.tabla, parser.tipoActual, a.toString(), b.toString(), parser.jerarquia, c.toString()); parser.claseUsar = parser.verif.devolverClaseJava(b.toString(), parser.tabla.getObJava()); :} PARAMETROS parentesis_b {: if(parser.metodoCorrecto){  } :}
;
    METODOS_MAIN ::= python:a punto id:b parentesis_a {: parser.len=a.toString();   parser.metodoCorrecto=parser.verif.verificarMetodo(parser.tabla, a.toString(), null, parser.jerarquia, b.toString()); :} PARAMETROS:c parentesis_b puntoComa ENTER2  
    |           visual:a punto id:b parentesis_a {: parser.len=a.toString(); parser.metodoCorrecto=parser.verif.verificarMetodo(parser.tabla, a.toString(), null, parser.jerarquia, b.toString());  :} PARAMETROS:c parentesis_b puntoComa ENTER2 
    |           java:a punto id:b punto id:c parentesis_a {: parser.len=a.toString(); parser.metodoCorrecto=parser.verif.verificarMetodo(parser.tabla, a.toString(), b.toString(), parser.jerarquia, c.toString()); parser.claseUsar = parser.verif.devolverClaseJava(b.toString(), parser.tabla.getObJava()); :} PARAMETROS:d parentesis_b puntoComa ENTER2
;
    PARAMETROS ::= {: parser.tipoActual = parser.verif.verifParametrosMetodo(parser.tabla, parser.it, parser.len, parser.claseUsar); parser.it++; :} OPERACION:a PARAMETROS2:b {: if(a && b){ RESULT=true; } else { RESULT=false; } :}
    | {:RESULT=parser.verif.verUltimoParametro(parser.tabla, parser.it, parser.len, parser.claseUsar); parser.it = 0;   parser.len = ""; parser.claseUsar = null; :}
;
    PARAMETROS2 ::= coma {: parser.tipoActual = parser.verif.verifParametrosMetodo(parser.tabla, parser.it, parser.len, parser.claseUsar); parser.it++; :} OPERACION:a  PARAMETROS2:b {:  if(a && b){ RESULT=true; } else { RESULT=false; }   :}
    | {:  RESULT=parser.verif.verUltimoParametro(parser.tabla, parser.it, parser.len, parser.claseUsar); parser.it = 0;   parser.len=""; parser.claseUsar=null; :}
;
    CLASES ::= java:a punto id:b id:c {: parser.idClase = b.toString(); :} CONSTRUCTOR:d {: parser.op.crearClase(parser.tabla, d, b.toString(), c.toString(), parser.jerarquia); :} CLASES2 puntoComa ENTER2
    |          java:a punto id:b id:c {: parser.idClase = b.toString(); parser.op.agregarClase(parser.tabla.getObC(), c.toString(), b.toString(), parser.jerarquia); :} CLASES2 puntoComa ENTER2
;
    CONSTRUCTOR ::= parentesis_a PARAM:a parentesis_b {: RESULT=a; :}
    |               parentesis_a parentesis_b {: RESULT=new ArrayList<>(); :}
;
    PARAM ::= PARAM2:a OP_COND:b {: if(a!=null){ if(!b.equals("")){ a.add(b); RESULT=a; } else { RESULT=null; } } :}
;
    PARAM2 ::= PARAM2:a OP_COND:b coma {: if(a!=null){ if(!b.equals("")) { a.add(b); RESULT=a; } else { RESULT=null; } } :}
    | {: RESULT=new ArrayList<>(); :}
;
    CLASES2 ::= coma id:a CONSTRUCTOR:b {: parser.op.crearClase(parser.tabla, b, parser.idClase, a.toString(), parser.jerarquia); :}  CLASES2
    |           coma id:a {: parser.op.agregarClase(parser.tabla.getObC(), a.toString(), parser.idClase, parser.jerarquia); :}  CLASES2
    |
;
    IF ::= condIf parentesis_a EXT parentesis_b ENTER2 {: parser.jerarquia++; :} llave_a ENTER2 CUERPO_MAIN llave_b {: parser.op.eliminarVarAmbitos(parser.tabla.getObC(), parser.jerarquia); parser.jerarquia--; :} ENTER2 ELSE
;
    BOOLEAN ::= OP_COND:a OP OP_COND:b {: if(!a.equals("") && !b.equals("")){ RESULT=parser.verif.verifOpCondicional(parser.tabla.getObC(), a, b); } else { RESULT=""; } :} 
    |           verdadero {: RESULT="true"; :}
    |           falso  {: RESULT="true"; :}
;
    OP ::= mayor
    |      menor
    |      mayor igual
    |      menor igual
    |      igual igual
    |      admiracion igual
;
    EXT ::= EXT:a and EXT:b {: if(a && b){ RESULT=true; } else { RESULT=false; } :}
    |       EXT:b or EXT:a {: if(a && b){ RESULT=true; } else { RESULT=false; } :} 
    |       BOOLEAN:a {: if(!a.equals("")){ RESULT=true; } else { RESULT=false; } :}
    |       admiracion parentesis_a BOOLEAN:a parentesis_b {: if(!a.equals("")){ RESULT=true; } else { RESULT=false; } :}
    |       admiracion BOOLEAN:a {: if(!a.equals("")){ RESULT=true; } else { RESULT=false; } :}
;
    OP_COND ::= parentesis_a OP_COND:a parentesis_b {: RESULT=a; :}
    |           OP_COND:a mas OP_COND:b {: if(!a.equals("") && !b.equals("")){ RESULT=parser.verif.verifOpCondicional(parser.tabla.getObC(), a, b); } else { RESULT=""; } :}
    |           OP_COND:a menos OP_COND:b {: if(!a.equals("") && !b.equals("")){ RESULT=parser.verif.verifOpCondicional(parser.tabla.getObC(), a, b); } else { RESULT=""; } :}
    |           OP_COND:a por OP_COND:b {: if(!a.equals("") && !b.equals("")){ RESULT=parser.verif.verifOpCondicional(parser.tabla.getObC(), a, b); } else { RESULT=""; } :}
    |           OP_COND:a div OP_COND:b {: if(!a.equals("") && !b.equals("")){ RESULT=parser.verif.verifOpCondicional(parser.tabla.getObC(), a, b); } else { RESULT=""; } :}
    |           OP_COND:a modulo OP_COND:b {: if(!a.equals("") && !b.equals("")){ RESULT=parser.verif.verifOpCondicional(parser.tabla.getObC(), a , b); } else { RESULT=""; } :}
    |           VAL_COND:a {: RESULT=a; :}
;
    VAL_COND ::= comillaSimple id comillaSimple {: RESULT="Char"; :}
    |            numero:a {: RESULT = "Integer"; :}
    |            numero:a punto:b numero:c {: RESULT="Float"; :}
    |            VECTOR_COND:a {: RESULT=a; :}
    |            METODO_COND:a {: RESULT=a; :}
    |            id:a {: RESULT=parser.op.devolverTipoVar(parser.tabla.getObC(), a.toString(), parser.jerarquia); :}
    |            menos numero:a {: RESULT = "Integer"; :}
    |            menos numero:a punto:b numero:c {: RESULT="Float"; :}
    |            menos VECTOR_COND:a {: RESULT=a; :}
    |            menos METODO_COND:a {: RESULT=a; :}
    |            menos id:a {: RESULT=parser.op.devolverTipoVar(parser.tabla.getObC(), a.toString(), parser.jerarquia); :}
;    
    VECTOR_COND ::= id:a DIM:b {: RESULT=parser.op.devolverTipoArreglo(parser.tabla.getObC(), a.toString(), b, parser.jerarquia); :}
;
    METODO_COND ::= python:a punto id:b parentesis_a  {: parser.len=a.toString(); parser.metodoCorrecto=parser.verif.verificarMetodoOp(parser.tabla, parser.tipoActual, a.toString(), "", parser.jerarquia, b.toString());  :}  PARAMETROS:c parentesis_b {: if(parser.metodoCorrecto){ if(c){ RESULT=parser.tabla.getObPython().getMisMetodos().get(parser.itMetodo).getRetorno(); } else { RESULT="";  } } else { RESULT=""; }  :}
    |           visual:a punto id:b parentesis_a {: parser.len=a.toString(); parser.metodoCorrecto=parser.verif.verificarMetodoOp(parser.tabla, parser.tipoActual, a.toString(), "", parser.jerarquia, b.toString()); :} PARAMETROS:c parentesis_b {: if(parser.metodoCorrecto){ if(c){ RESULT=parser.tabla.getObVb().getMisMetodos().get(parser.itMetodo).getRetorno();  } else { RESULT=""; } } else { RESULT=""; } :}
    |           java:a punto id:b punto id:c parentesis_a {: parser.len=a.toString(); parser.metodoCorrecto=parser.verif.verificarMetodoOp(parser.tabla, parser.tipoActual, a.toString(), b.toString(), parser.jerarquia, c.toString()); parser.claseUsar = parser.verif.devolverClaseJava(b.toString(), parser.tabla.getObJava()); :} PARAMETROS:d parentesis_b {: if(parser.metodoCorrecto){ if(d){ RESULT=parser.claseUsar.getMisMetodos().get(parser.itMetodo).getRetorno(); } else { RESULT=""; } } else { RESULT=""; } :}
;

    ELSE ::= condElse condIf parentesis_a  EXT parentesis_b ENTER2 {: parser.jerarquia++; :} llave_a ENTER2 CUERPO_MAIN llave_b {: parser.op.eliminarVarAmbitos(parser.tabla.getObC(), parser.jerarquia); parser.jerarquia--; :} ENTER2 ELSE
    |        condElse ENTER2 {: parser.jerarquia++; :} llave_a ENTER2 CUERPO_MAIN llave_b {: parser.op.eliminarVarAmbitos(parser.tabla.getObC(), parser.jerarquia); parser.jerarquia--; :} ENTER2
    |
;
    FOR ::= condFor {: parser.jerarquia++; :} parentesis_a TIPO_VAR_FOR:a id:b igual VAR_FOR:h puntoComa {: if(h){ parser.auxFor= parser.verif.verifVarFor(parser.tabla.getObC(), b.toString(), a, "Integer", parser.jerarquia); } else { parser.auxFor=false; } parser.tipoActual="Integer"; :} BOOLEAN:c puntoComa id:d igual id:e mas VAR_FOR:f parentesis_b {:  parser.verif.verificarFor(parser.tabla.getObC(), parser.jerarquia, parser.auxFor, c, d.toString(), e.toString(), parser.tipoActual, f, a, b.toString());  :} ENTER2 llave_a ENTER2 CUERPO_MAIN llave_b {: parser.op.eliminarVarAmbitos(parser.tabla.getObC(), parser.jerarquia); parser.jerarquia--; :} ENTER2
;
    TIPO_VAR_FOR ::= tipoInteger {: RESULT="Integer"; :}
    |                tipoFloat {: RESULT="Float"; :}
    |                tipoChar {: RESULT="Char"; :}  
    |                {: RESULT=""; :}
;
    VAR_FOR ::= numero:a {: RESULT=parser.verif.verificarNumero(parser.tabla.getObC(), "Integer", "Integer", a.toString()); :}
    |           id:a {: RESULT=parser.verif.verificarIdOperacion(parser.tabla.getObC(), a.toString(), parser.jerarquia, "Integer");   :} 
;
    WHILE ::= condWhile  parentesis_a EXT parentesis_b ENTER2 {: parser.jerarquia++; :} llave_a ENTER2 CUERPO_MAIN llave_b {: parser.op.eliminarVarAmbitos(parser.tabla.getObC(), parser.jerarquia); parser.jerarquia--; :} ENTER2
;
    DO_WHILE ::= condDo ENTER2 {: parser.jerarquia++; :} llave_a ENTER2 CUERPO_MAIN llave_b ENTER2 condWhile parentesis_a EXT parentesis_b puntoComa {: parser.op.eliminarVarAmbitos(parser.tabla.getObC(), parser.jerarquia); parser.jerarquia--; :} ENTER2
;
    SWITCH ::= condSwitch {: parser.tipoActual="Integer"; :} parentesis_a VAR_LECTURA:a parentesis_b ENTER2 {: parser.jerarquia++; :} llave_a ENTER2 CASES llave_b {: parser.op.eliminarVarAmbitos(parser.tabla.getObC(), parser.jerarquia); parser.jerarquia--; :} ENTER2
;
    CASES ::= condCase VAR_CASE dosPuntos {: parser.jerarquia++; :} ENTER CUERPO_MAIN BREAK {: parser.op.eliminarVarAmbitos(parser.tabla.getObC(), parser.jerarquia); parser.jerarquia--; :} CASES
    |         condDef dosPuntos {: parser.jerarquia++; :} ENTER CUERPO_MAIN BREAK {: parser.op.eliminarVarAmbitos(parser.tabla.getObC(), parser.jerarquia); parser.jerarquia--; :}
    |       
;
    BREAK ::= condBreak puntoComa ENTER2
    |
;
    VAR_CASE ::= numero
    |            comillaSimple id comillaSimple
;
    LECTURA_DATOS ::= scanf parentesis_a comilla TEXTO MODULOS:a {: parser.tipoActual=a; :} comilla coma ampersand VAR_LECTURA:b parentesis_b puntoComa ENTER2
;
    MODULOS ::= scanfInt:a {: RESULT="Integer"; :}
    |           scanfFloat:a {: RESULT="Float"; :}
    |           scanfChar:a {: RESULT="Char"; :}
;
    VAR_LECTURA ::= id:a {: RESULT = parser.verif.verificarIdOperacion(parser.tabla.getObC(), a.toString(), parser.jerarquia, parser.tipoActual);   :}
    |               VECTOR_OP:a {: RESULT=a; :}
;
    MENSAJE ::= printf parentesis_a {: parser.tipoActual="Float"; :} comilla TEXTO2  comilla RESTO_MENSAJE parentesis_b puntoComa ENTER2
    |           printf parentesis_a {: parser.tipoActual="Float"; :} VAR_TEXTO RESTO_MENSAJE parentesis_b puntoComa ENTER2
;
    RESTO_MENSAJE ::= coma comilla TEXTO2 comilla RESTO_MENSAJE
    |                 coma VAR_TEXTO RESTO_MENSAJE
    |
;
    CLSCR ::= clscr parentesis_a parentesis_b puntoComa ENTER2
;
    GETCH ::= id:a igual getch parentesis_a parentesis_b puntoComa  {: parser.tipoActual=parser.verif.devolverTipoVar(parser.tabla.getObC(), parser.jerarquia, a.toString());  if(parser.tipoActual.equals("Integer") || parser.tipoActual.equals("Char")){} else { System.out.println("var "+a.toString()+" con valor incorrecto para asignacion de getch"); } :} ENTER2
    |         VECTOR:a igual getch parentesis_a parentesis_b puntoComa {: if(a){ if(!parser.tipoActual.equals("Integer") || !parser.tipoActual.equals("Char")){ System.out.println("arreglo "+a.toString()+" con valor incorrecto para asignacion de getch");  } } else { System.out.println("Variable no existe para poder asignar getch"); } :} ENTER2
    |         getch parentesis_a parentesis_b puntoComa ENTER2
;
   VAR_TEXTO ::=  id:a {: RESULT=parser.verif.verificarIdOperacion(parser.tabla.getObC(), a.toString(), parser.jerarquia, parser.tipoActual); :}
    |             ampersand id
    |             VECTOR:a {: RESULT=a; :}
    |             ampersand VECTOR 
    |             METODOS:a {:  :}
    |             numero {: RESULT=true; :}
    |             numero punto numero {: RESULT=true; :}
;
    COMENTARIO_A ::= comentario_a TEXTO ENTER
;
    COMENTARIO_B ::= comentario_b TEXTO_COM comentario_c ENTER2
;
    ENTER ::= ENTER enter
    |         enter
;
    ENTER2 ::= ENTER enter
    |          enter
    |
;
    TEXTO ::= TEXTO:a coma:b {: RESULT=a + b.toString(); :}
    |         TEXTO:a punto:b {: RESULT=a + b.toString(); :} 
    |         TEXTO:a puntoComa:b {: RESULT= a + b.toString(); :}
    |         TEXTO:a dosPuntos:b {: RESULT= a + b.toString(); :}
    |         TEXTO:a llave_a:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a llave_b:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a parentesis_a:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a parentesis_b:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a agrupacion_a:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a agrupacion_b:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a comillaSimple:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a condBreak:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a condInclude:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a visual:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a python:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a java:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a principal:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a mas:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a menos:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a por:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a div:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a numeral:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a tipoVoid:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a tipoInteger:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a tipoChar:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a tipoConst:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a verdadero:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a falso:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a main:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a mayor:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a menor:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a igual:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a admiracion:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a ampersand:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a pleca:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a condIf:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a condElse:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a condSwitch:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a condCase:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a condDef:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a condFor:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a condWhile:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a condDo:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a printf:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a scanf:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a clscr:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a getch:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a numero:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a id:b {: RESULT = a + b.toString(); :}
    |         TEXTO:a resto:b {: RESULT = a + b.toString(); :}
    |
;
    TEXTO2 ::= TEXTO2:a coma:b {: RESULT=a + b.toString(); :}
    |         TEXTO2:a punto:b {: RESULT=a + b.toString(); :} 
    |         TEXTO2:a puntoComa:b {: RESULT= a + b.toString(); :}
    |         TEXTO2:a dosPuntos:b {: RESULT= a + b.toString(); :}
    |         TEXTO2:a llave_a:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a llave_b:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a parentesis_a:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a parentesis_b:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a agrupacion_a:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a agrupacion_b:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a comillaSimple:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a condBreak:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a condInclude:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a visual:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a python:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a java:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a principal:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a mas:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a menos:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a por:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a div:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a numeral:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a tipoVoid:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a tipoInteger:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a tipoChar:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a tipoConst:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a verdadero:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a falso:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a main:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a mayor:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a menor:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a igual:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a admiracion:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a ampersand:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a pleca:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a condIf:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a condElse:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a condSwitch:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a condCase:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a condDef:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a condFor:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a condWhile:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a condDo:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a printf:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a scanf:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a clscr:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a getch:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a numero:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a id:b {: RESULT = a + b.toString(); :}
    |         TEXTO2:a MODULOS {:  :}
    |         TEXTO2:a resto:b {: RESULT = a + b.toString(); :}
    |
;
    TEXTO_COM ::= TEXTO_COM:a coma:b {: RESULT=a + b.toString(); :}
    |         TEXTO_COM:a punto:b {: RESULT=a + b.toString(); :} 
    |         TEXTO_COM:a puntoComa:b {: RESULT= a + b.toString(); :}
    |         TEXTO_COM:a dosPuntos:b {: RESULT= a + b.toString(); :}
    |         TEXTO_COM:a llave_a:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a llave_b:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a parentesis_a:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a parentesis_b:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a agrupacion_a:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a agrupacion_b:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a comillaSimple:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a condBreak:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a condInclude:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a visual:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a python:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a java:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a principal:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a mas:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a menos:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a por:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a div:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a numeral:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a tipoVoid:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a tipoInteger:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a tipoChar:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a tipoConst:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a verdadero:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a falso:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a main:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a mayor:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a menor:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a igual:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a admiracion:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a ampersand:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a pleca:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a condIf:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a condElse:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a condSwitch:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a condCase:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a condDef:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a condFor:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a condWhile:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a condDo:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a printf:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a scanf:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a clscr:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a getch:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a numero:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a id:b {: RESULT = a + b.toString(); :}
    |         TEXTO_COM:a MODULOS {:  :}
    |         TEXTO_COM:a enter {: RESULT = a + "\n";  :}
    |         TEXTO_COM:a resto:b {: RESULT = a + b.toString(); :}
    |
;
